"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const node_crypto_1 = require("node:crypto");
const node_console_1 = require("node:console");
const commons_1 = require("@aws-lambda-powertools/commons");
const formatter_1 = require("./formatter");
const log_1 = require("./log");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const config_1 = require("./config");
/**
 * ## Intro
 * The Logger utility provides an opinionated logger with output structured as JSON.
 *
 * ## Key features
 *  * Capture key fields from Lambda context, cold start and structures logging output as JSON
 *  * Log Lambda context when instructed (disabled by default)
 *  * Log sampling prints all logs for a percentage of invocations (disabled by default)
 *  * Append additional keys to structured log at any point in time
 *
 * ## Usage
 *
 * For more usage examples, see [our documentation](https://docs.powertools.aws.dev/lambda-typescript/latest/core/logger/).
 *
 * ### Basic usage
 *
 * @example
 * ```typescript
 * import { Logger } from '@aws-lambda-powertools/logger';
 *
 * // Logger parameters fetched from the environment variables:
 * const logger = new Logger();
 * ```
 *
 * ### Functions usage with middleware
 *
 * If you use function-based Lambda handlers you can use the [injectLambdaContext()](#injectLambdaContext)
 * middy middleware to automatically add context to your Lambda logs.
 *
 * @example
 * ```typescript
 * import { Logger, injectLambdaContext } from '@aws-lambda-powertools/logger';
 * import middy from '@middy/core';
 *
 * const logger = new Logger();
 *
 * const lambdaHandler = async (_event: any, _context: any) => {
 *     logger.info('This is an INFO log with some context');
 * };
 *
 * export const handler = middy(lambdaHandler).use(injectLambdaContext(logger));
 * ```
 *
 * ### Object oriented usage with decorators
 *
 * If instead you use TypeScript classes to wrap your Lambda handler you can use the [@logger.injectLambdaContext()](./_aws_lambda_powertools_logger.Logger.html#injectLambdaContext) decorator.
 *
 * @example
 * ```typescript
 * import { Logger } from '@aws-lambda-powertools/logger';
 * import { LambdaInterface } from '@aws-lambda-powertools/commons';
 *
 * const logger = new Logger();
 *
 * class Lambda implements LambdaInterface {
 *
 *   // FYI: Decorator might not render properly in VSCode mouse over due to https://github.com/microsoft/TypeScript/issues/47679 and might show as *@logger* instead of `@logger.injectLambdaContext`
 *
 *     // Decorate your handler class method
 *     @logger.injectLambdaContext()
 *     public async handler(_event: any, _context: any): Promise<void> {
 *         logger.info('This is an INFO log with some context');
 *     }
 * }
 *
 * const handlerClass = new Lambda();
 * export const handler = handlerClass.handler.bind(handlerClass);
 * ```
 *
 * ### Functions usage with manual instrumentation
 *
 * If you prefer to manually instrument your Lambda handler you can use the methods in the Logger class directly.
 *
 * @example
 * ```typescript
 * import { Logger } from '@aws-lambda-powertools/logger';
 *
 * const logger = new Logger();
 *
 * export const handler = async (_event, context) => {
 *     logger.addContext(context);
 *     logger.info('This is an INFO log with some context');
 * };
 * ```
 *
 * @class
 * @implements {ClassThatLogs}
 * @see https://docs.powertools.aws.dev/lambda-typescript/latest/core/logger/
 */
class Logger extends commons_1.Utility {
    /**
     * Log level used by the current instance of Logger.
     *
     * Returns the log level as a number. The higher the number, the less verbose the logs.
     * To get the log level name, use the {@link getLevelName()} method.
     */
    get level() {
        return this.logLevel;
    }
    /**
     * It initializes the Logger class with an optional set of options (settings).
     * *
     * @param {ConstructorOptions} options
     */
    constructor(options = {}) {
        super();
        this.logEvent = false;
        this.logIndentation = 0 /* LogJsonIndent.COMPACT */;
        /**
         * Log level used internally by the current instance of Logger.
         */
        this.logLevel = 12;
        /**
         * Log level thresholds used internally by the current instance of Logger.
         *
         * The levels are in ascending order from the most verbose to the least verbose (no logs).
         */
        this.logLevelThresholds = {
            DEBUG: 8,
            INFO: 12,
            WARN: 16,
            ERROR: 20,
            CRITICAL: 24,
            SILENT: 28,
        };
        this.logsSampled = false;
        this.persistentLogAttributes = {};
        this.powertoolLogData = {};
        this.setOptions(options);
    }
    /**
     * It adds the current Lambda function's invocation context data to the powertoolLogData property of the instance.
     * This context data will be part of all printed log items.
     *
     * @param {Context} context
     * @returns {void}
     */
    addContext(context) {
        const lambdaContext = {
            invokedFunctionArn: context.invokedFunctionArn,
            coldStart: this.getColdStart(),
            awsRequestId: context.awsRequestId,
            memoryLimitInMB: Number(context.memoryLimitInMB),
            functionName: context.functionName,
            functionVersion: context.functionVersion,
        };
        this.addToPowertoolLogData({
            lambdaContext,
        });
    }
    /**
     * It adds the given attributes (key-value pairs) to all log items generated by this Logger instance.
     *
     * @param {LogAttributes} attributes
     * @returns {void}
     */
    addPersistentLogAttributes(attributes) {
        (0, lodash_merge_1.default)(this.persistentLogAttributes, attributes);
    }
    /**
     * Alias for addPersistentLogAttributes.
     *
     * @param {LogAttributes} attributes
     * @returns {void}
     */
    appendKeys(attributes) {
        this.addPersistentLogAttributes(attributes);
    }
    /**
     * It creates a separate Logger instance, identical to the current one
     * It's possible to overwrite the new instance options by passing them.
     *
     * @param {ConstructorOptions} options
     * @returns {Logger}
     */
    createChild(options = {}) {
        const parentsOptions = {
            logLevel: this.getLevelName(),
            customConfigService: this.getCustomConfigService(),
            logFormatter: this.getLogFormatter(),
        };
        const parentsPowertoolsLogData = this.getPowertoolLogData();
        const childLogger = new Logger((0, lodash_merge_1.default)(parentsOptions, parentsPowertoolsLogData, options));
        const parentsPersistentLogAttributes = this.getPersistentLogAttributes();
        childLogger.addPersistentLogAttributes(parentsPersistentLogAttributes);
        if (parentsPowertoolsLogData.lambdaContext) {
            childLogger.addContext(parentsPowertoolsLogData.lambdaContext);
        }
        return childLogger;
    }
    /**
     * It prints a log item with level CRITICAL.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | string} extraInput
     */
    critical(input, ...extraInput) {
        this.processLogItem(24, input, extraInput);
    }
    /**
     * It prints a log item with level DEBUG.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | string} extraInput
     * @returns {void}
     */
    debug(input, ...extraInput) {
        this.processLogItem(8, input, extraInput);
    }
    /**
     * It prints a log item with level ERROR.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | string} extraInput
     * @returns {void}
     */
    error(input, ...extraInput) {
        this.processLogItem(20, input, extraInput);
    }
    /**
     * Get the log level name of the current instance of Logger.
     *
     * It returns the log level name, i.e. `INFO`, `DEBUG`, etc.
     * To get the log level as a number, use the {@link Logger.level} property.
     *
     * @returns {Uppercase<LogLevel>} The log level name.
     */
    getLevelName() {
        return this.getLogLevelNameFromNumber(this.logLevel);
    }
    /**
     * It returns a boolean value. True means that the Lambda invocation events
     * are printed in the logs.
     *
     * @returns {boolean}
     */
    getLogEvent() {
        return this.logEvent;
    }
    /**
     * It returns a boolean value, if true all the logs will be printed.
     *
     * @returns {boolean}
     */
    getLogsSampled() {
        return this.logsSampled;
    }
    /**
     * It returns the persistent log attributes, which are the attributes
     * that will be logged in all log items.
     *
     * @private
     * @returns {LogAttributes}
     */
    getPersistentLogAttributes() {
        return this.persistentLogAttributes;
    }
    /**
     * It prints a log item with level INFO.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | string} extraInput
     * @returns {void}
     */
    info(input, ...extraInput) {
        this.processLogItem(12, input, extraInput);
    }
    /**
     * Method decorator that adds the current Lambda function context as extra
     * information in all log items.
     *
     * The decorator can be used only when attached to a Lambda function handler which
     * is written as method of a class, and should be declared just before the handler declaration.
     *
     * Note: Currently TypeScript only supports decorators on classes and methods. If you are using the
     * function syntax, you should use the middleware instead.
     *
     * @example
     * ```typescript
     * import { Logger } from '@aws-lambda-powertools/logger';
     * import { LambdaInterface } from '@aws-lambda-powertools/commons';
     *
     * const logger = new Logger();
     *
     * class Lambda implements LambdaInterface {
     *     // Decorate your handler class method
     *     @logger.injectLambdaContext()
     *     public async handler(_event: any, _context: any): Promise<void> {
     *         logger.info('This is an INFO log with some context');
     *     }
     * }
     *
     * const handlerClass = new Lambda();
     * export const handler = handlerClass.handler.bind(handlerClass);
     * ```
     *
     * @see https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators
     * @returns {HandlerMethodDecorator}
     */
    injectLambdaContext(options) {
        return (_target, _propertyKey, descriptor) => {
            /**
             * The descriptor.value is the method this decorator decorates, it cannot be undefined.
             */
            /* eslint-disable  @typescript-eslint/no-non-null-assertion */
            const originalMethod = descriptor.value;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const loggerRef = this;
            // Use a function() {} instead of an () => {} arrow function so that we can
            // access `myClass` as `this` in a decorated `myClass.myMethod()`.
            descriptor.value = async function (event, context, callback) {
                let initialPersistentAttributes = {};
                if (options && options.clearState === true) {
                    initialPersistentAttributes = {
                        ...loggerRef.getPersistentLogAttributes(),
                    };
                }
                Logger.injectLambdaContextBefore(loggerRef, event, context, options);
                let result;
                try {
                    result = await originalMethod.apply(this, [event, context, callback]);
                }
                catch (error) {
                    throw error;
                }
                finally {
                    Logger.injectLambdaContextAfterOrOnError(loggerRef, initialPersistentAttributes, options);
                }
                return result;
            };
        };
    }
    static injectLambdaContextAfterOrOnError(logger, initialPersistentAttributes, options) {
        if (options && options.clearState === true) {
            logger.setPersistentLogAttributes(initialPersistentAttributes);
        }
    }
    static injectLambdaContextBefore(logger, event, context, options) {
        logger.addContext(context);
        let shouldLogEvent = undefined;
        if (options && options.hasOwnProperty('logEvent')) {
            shouldLogEvent = options.logEvent;
        }
        logger.logEventIfEnabled(event, shouldLogEvent);
    }
    /**
     * Logs a Lambda invocation event, if it *should*.
     *
     ** @param {unknown} event
     * @param {boolean} [overwriteValue]
     * @returns {void}
     */
    logEventIfEnabled(event, overwriteValue) {
        if (!this.shouldLogEvent(overwriteValue)) {
            return;
        }
        this.info('Lambda invocation event', { event });
    }
    /**
     * If the sample rate feature is enabled, the calculation that determines whether the logs
     * will actually be printed or not for this invocation is done when the Logger class is
     * initialized.
     * This method will repeat that calculation (with possible different outcome).
     *
     * @returns {void}
     */
    refreshSampleRateCalculation() {
        this.setLogsSampled();
    }
    /**
     * Alias for removePersistentLogAttributes.
     *
     * @param {string[]} keys
     * @returns {void}
     */
    removeKeys(keys) {
        this.removePersistentLogAttributes(keys);
    }
    /**
     * It removes attributes based on provided keys to all log items generated by this Logger instance.
     *
     * @param {string[]} keys
     * @returns {void}
     */
    removePersistentLogAttributes(keys) {
        keys.forEach((key) => {
            if (this.persistentLogAttributes && key in this.persistentLogAttributes) {
                delete this.persistentLogAttributes[key];
            }
        });
    }
    /**
     * Set the log level for this Logger instance.
     *
     * @param logLevel The log level to set, i.e. `error`, `warn`, `info`, `debug`, etc.
     */
    setLogLevel(logLevel) {
        if (this.isValidLogLevel(logLevel)) {
            this.logLevel = this.logLevelThresholds[logLevel];
        }
        else {
            throw new Error(`Invalid log level: ${logLevel}`);
        }
    }
    /**
     * It sets the given attributes (key-value pairs) to all log items generated by this Logger instance.
     * Note: this replaces the pre-existing value.
     *
     * @param {LogAttributes} attributes
     * @returns {void}
     */
    setPersistentLogAttributes(attributes) {
        this.persistentLogAttributes = attributes;
    }
    /**
     * It sets the user-provided sample rate value.
     *
     * @param {number} [sampleRateValue]
     * @returns {void}
     */
    setSampleRateValue(sampleRateValue) {
        this.powertoolLogData.sampleRateValue =
            sampleRateValue ||
                this.getCustomConfigService()?.getSampleRateValue() ||
                this.getEnvVarsService().getSampleRateValue();
    }
    /**
     * It checks whether the current Lambda invocation event should be printed in the logs or not.
     *
     * @private
     * @param {boolean} [overwriteValue]
     * @returns {boolean}
     */
    shouldLogEvent(overwriteValue) {
        if (typeof overwriteValue === 'boolean') {
            return overwriteValue;
        }
        return this.getLogEvent();
    }
    /**
     * It prints a log item with level WARN.
     *
     * @param {LogItemMessage} input
     * @param {Error | LogAttributes | string} extraInput
     * @returns {void}
     */
    warn(input, ...extraInput) {
        this.processLogItem(16, input, extraInput);
    }
    /**
     * Decides whether the current log item should be printed or not.
     *
     * The decision is based on the log level and the sample rate value.
     * A log item will be printed if:
     * 1. The log level is greater than or equal to the Logger's log level.
     * 2. The log level is less than the Logger's log level, but the
     * current sampling value is set to `true`.
     *
     * @param {number} logLevel
     * @returns {boolean}
     * @protected
     */
    shouldPrint(logLevel) {
        if (logLevel >= this.logLevel) {
            return true;
        }
        return this.getLogsSampled();
    }
    /**
     * It stores information that is printed in all log items.
     *
     * @param {Partial<PowertoolLogData>} attributesArray
     * @private
     * @returns {void}
     */
    addToPowertoolLogData(...attributesArray) {
        attributesArray.forEach((attributes) => {
            (0, lodash_merge_1.default)(this.powertoolLogData, attributes);
        });
    }
    /**
     * It processes a particular log item so that it can be printed to stdout:
     * - Merges ephemeral log attributes with persistent log attributes (printed for all logs) and additional info;
     * - Formats all the log attributes;
     *
     * @private
     * @param {number} logLevel
     * @param {LogItemMessage} input
     * @param {LogItemExtraInput} extraInput
     * @returns {LogItem}
     */
    createAndPopulateLogItem(logLevel, input, extraInput) {
        // TODO: this method's logic is hard to understand, there is an opportunity here to simplify this logic.
        const unformattedBaseAttributes = (0, lodash_merge_1.default)({
            logLevel: this.getLogLevelNameFromNumber(logLevel),
            timestamp: new Date(),
            message: typeof input === 'string' ? input : input.message,
            xRayTraceId: this.envVarsService.getXrayTraceId(),
        }, this.getPowertoolLogData());
        const logItem = new log_1.LogItem({
            baseAttributes: this.getLogFormatter().formatAttributes(unformattedBaseAttributes),
            persistentAttributes: this.getPersistentLogAttributes(),
        });
        // Add ephemeral attributes
        if (typeof input !== 'string') {
            logItem.addAttributes(input);
        }
        extraInput.forEach((item) => {
            const attributes = item instanceof Error
                ? { error: item }
                : typeof item === 'string'
                    ? { extra: item }
                    : item;
            logItem.addAttributes(attributes);
        });
        return logItem;
    }
    /**
     * It returns the custom config service, an abstraction used to fetch environment variables.
     *
     * @private
     * @returns {ConfigServiceInterface | undefined}
     */
    getCustomConfigService() {
        return this.customConfigService;
    }
    /**
     * It returns the instance of a service that fetches environment variables.
     *
     * @private
     * @returns {EnvironmentVariablesService}
     */
    getEnvVarsService() {
        return this.envVarsService;
    }
    /**
     * It returns the instance of a service that formats the structure of a
     * log item's keys and values in the desired way.
     *
     * @private
     * @returns {LogFormatterInterface}
     */
    getLogFormatter() {
        return this.logFormatter;
    }
    /**
     * Get the log level name from the log level number.
     *
     * For example, if the log level is 16, it will return 'WARN'.
     *
     * @param logLevel - The log level to get the name of
     * @returns - The name of the log level
     */
    getLogLevelNameFromNumber(logLevel) {
        const found = Object.entries(this.logLevelThresholds).find(([key, value]) => {
            if (value === logLevel) {
                return key;
            }
        });
        return found[0];
    }
    /**
     * It returns information that will be added in all log item by
     * this Logger instance (different from user-provided persistent attributes).
     *
     * @private
     * @returns {LogAttributes}
     */
    getPowertoolLogData() {
        return this.powertoolLogData;
    }
    /**
     * When the data added in the log item contains object references or BigInt values,
     * `JSON.stringify()` can't handle them and instead throws errors:
     * `TypeError: cyclic object value` or `TypeError: Do not know how to serialize a BigInt`.
     * To mitigate these issues, this method will find and remove all cyclic references and convert BigInt values to strings.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#exceptions
     * @private
     */
    getReplacer() {
        const references = new WeakSet();
        return (key, value) => {
            let item = value;
            if (item instanceof Error) {
                item = this.getLogFormatter().formatError(item);
            }
            if (typeof item === 'bigint') {
                return item.toString();
            }
            if (typeof item === 'object' && value !== null) {
                if (references.has(item)) {
                    return;
                }
                references.add(item);
            }
            return item;
        };
    }
    /**
     * It returns the numeric sample rate value.
     *
     * @private
     * @returns {number}
     */
    getSampleRateValue() {
        if (!this.powertoolLogData.sampleRateValue) {
            this.setSampleRateValue();
        }
        return this.powertoolLogData.sampleRateValue;
    }
    /**
     * It returns true and type guards the log level if a given log level is valid.
     *
     * @param {LogLevel} logLevel
     * @private
     * @returns {boolean}
     */
    isValidLogLevel(logLevel) {
        return typeof logLevel === 'string' && logLevel in this.logLevelThresholds;
    }
    /**
     * It prints a given log with given log level.
     *
     * @param {number} logLevel
     * @param {LogItem} log
     * @private
     */
    printLog(logLevel, log) {
        log.prepareForPrint();
        const consoleMethod = logLevel === 24
            ? 'error'
            : this.getLogLevelNameFromNumber(logLevel).toLowerCase();
        this.console[consoleMethod](JSON.stringify(log.getAttributes(), this.getReplacer(), this.logIndentation));
    }
    /**
     * It prints a given log with given log level.
     *
     * @param {number} logLevel
     * @param {LogItemMessage} input
     * @param {LogItemExtraInput} extraInput
     * @private
     */
    processLogItem(logLevel, input, extraInput) {
        if (!this.shouldPrint(logLevel)) {
            return;
        }
        this.printLog(logLevel, this.createAndPopulateLogItem(logLevel, input, extraInput));
    }
    /**
     * It initializes console property as an instance of the internal version of Console() class (PR #748)
     * or as the global node console if the `POWERTOOLS_DEV' env variable is set and has truthy value.
     *
     * @private
     * @returns {void}
     */
    setConsole() {
        if (!this.getEnvVarsService().isDevMode()) {
            this.console = new node_console_1.Console({
                stdout: process.stdout,
                stderr: process.stderr,
            });
        }
        else {
            this.console = console;
        }
    }
    /**
     * Sets the Logger's customer config service instance, which will be used
     * to fetch environment variables.
     *
     * @private
     * @param {ConfigServiceInterface} customConfigService
     * @returns {void}
     */
    setCustomConfigService(customConfigService) {
        this.customConfigService = customConfigService
            ? customConfigService
            : undefined;
    }
    /**
     * Sets the Logger's custom config service instance, which will be used
     * to fetch environment variables.
     *
     * @private
     * @returns {void}
     */
    setEnvVarsService() {
        this.envVarsService = new config_1.EnvironmentVariablesService();
    }
    /**
     * Sets the initial Logger log level based on the following order:
     * 1. If a log level is passed to the constructor, it sets it.
     * 2. If a log level is set via custom config service, it sets it.
     * 3. If a log level is set via env variables, it sets it.
     *
     * If none of the above is true, the default log level applies (INFO).
     *
     * @private
     * @param {LogLevel} [logLevel] - Log level passed to the constructor
     */
    setInitialLogLevel(logLevel) {
        const constructorLogLevel = logLevel?.toUpperCase();
        if (this.isValidLogLevel(constructorLogLevel)) {
            this.logLevel = this.logLevelThresholds[constructorLogLevel];
            return;
        }
        const customConfigValue = this.getCustomConfigService()
            ?.getLogLevel()
            ?.toUpperCase();
        if (this.isValidLogLevel(customConfigValue)) {
            this.logLevel = this.logLevelThresholds[customConfigValue];
            return;
        }
        const envVarsValue = this.getEnvVarsService()?.getLogLevel()?.toUpperCase();
        if (this.isValidLogLevel(envVarsValue)) {
            this.logLevel = this.logLevelThresholds[envVarsValue];
            return;
        }
    }
    /**
     * If the log event feature is enabled via env variable, it sets a property that tracks whether
     * the event passed to the Lambda function handler should be logged or not.
     *
     * @private
     * @returns {void}
     */
    setLogEvent() {
        if (this.getEnvVarsService().getLogEvent()) {
            this.logEvent = true;
        }
    }
    /**
     * It sets the log formatter instance, in charge of giving a custom format
     * to the structured logs
     *
     * @private
     * @param {LogFormatterInterface} logFormatter
     * @returns {void}
     */
    setLogFormatter(logFormatter) {
        this.logFormatter = logFormatter || new formatter_1.PowertoolLogFormatter();
    }
    /**
     * If the `POWERTOOLS_DEV' env variable is set,
     * it adds JSON indentation for pretty printing logs.
     *
     * @private
     * @returns {void}
     */
    setLogIndentation() {
        if (this.getEnvVarsService().isDevMode()) {
            this.logIndentation = 4 /* LogJsonIndent.PRETTY */;
        }
    }
    /**
     * If the sample rate feature is enabled, it sets a property that tracks whether this Lambda function invocation
     * will print logs or not.
     *
     * @private
     * @returns {void}
     */
    setLogsSampled() {
        const sampleRateValue = this.getSampleRateValue();
        this.logsSampled =
            sampleRateValue !== undefined &&
                (sampleRateValue === 1 || (0, node_crypto_1.randomInt)(0, 100) / 100 <= sampleRateValue);
    }
    /**
     * It configures the Logger instance settings that will affect the Logger's behaviour
     * and the content of all logs.
     *
     * @private
     * @param {ConstructorOptions} options
     * @returns {Logger}
     */
    setOptions(options) {
        const { logLevel, serviceName, sampleRateValue, logFormatter, customConfigService, persistentLogAttributes, environment, } = options;
        this.setEnvVarsService();
        // order is important, it uses EnvVarsService()
        this.setConsole();
        this.setCustomConfigService(customConfigService);
        this.setInitialLogLevel(logLevel);
        this.setSampleRateValue(sampleRateValue);
        this.setLogsSampled();
        this.setLogFormatter(logFormatter);
        this.setPowertoolLogData(serviceName, environment);
        this.setLogEvent();
        this.setLogIndentation();
        this.addPersistentLogAttributes(persistentLogAttributes);
        return this;
    }
    /**
     * It adds important data to the Logger instance that will affect the content of all logs.
     *
     * @param {string} serviceName
     * @param {Environment} environment
     * @param {LogAttributes} persistentLogAttributes
     * @private
     * @returns {void}
     */
    setPowertoolLogData(serviceName, environment, persistentLogAttributes = {}) {
        this.addToPowertoolLogData({
            awsRegion: this.getEnvVarsService().getAwsRegion(),
            environment: environment ||
                this.getCustomConfigService()?.getCurrentEnvironment() ||
                this.getEnvVarsService().getCurrentEnvironment(),
            sampleRateValue: this.getSampleRateValue(),
            serviceName: serviceName ||
                this.getCustomConfigService()?.getServiceName() ||
                this.getEnvVarsService().getServiceName() ||
                this.getDefaultServiceName(),
        }, persistentLogAttributes);
    }
}
exports.Logger = Logger;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9nZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0xvZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw2Q0FBd0M7QUFDeEMsK0NBQXVDO0FBRXZDLDREQUF5RDtBQUN6RCwyQ0FBMkU7QUFDM0UsK0JBQWdDO0FBQ2hDLGdFQUFpQztBQUNqQyxxQ0FBK0U7QUFpQi9FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0ZHO0FBQ0gsTUFBTSxNQUFPLFNBQVEsaUJBQU87SUFrRDFCOzs7OztPQUtHO0lBQ0gsSUFBVyxLQUFLO1FBQ2QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsWUFBbUIsVUFBOEIsRUFBRTtRQUNqRCxLQUFLLEVBQUUsQ0FBQztRQS9DRixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBSWpCLG1CQUFjLGlDQUFpQztRQUV2RDs7V0FFRztRQUNLLGFBQVEsR0FBRyxFQUFFLENBQUM7UUFFdEI7Ozs7V0FJRztRQUNjLHVCQUFrQixHQUF1QjtZQUN4RCxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksRUFBRSxFQUFFO1lBQ1IsSUFBSSxFQUFFLEVBQUU7WUFDUixLQUFLLEVBQUUsRUFBRTtZQUNULFFBQVEsRUFBRSxFQUFFO1lBQ1osTUFBTSxFQUFFLEVBQUU7U0FDWCxDQUFDO1FBRU0sZ0JBQVcsR0FBRyxLQUFLLENBQUM7UUFFcEIsNEJBQXVCLEdBQW1CLEVBQUUsQ0FBQztRQUU3QyxxQkFBZ0IsR0FBdUMsRUFBRSxDQUFDO1FBbUJoRSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxVQUFVLENBQUMsT0FBZ0I7UUFDaEMsTUFBTSxhQUFhLEdBQW1DO1lBQ3BELGtC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